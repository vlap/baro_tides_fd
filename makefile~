# Path for source files
VPATH = src/baro_utils:src/defs:src/generate:src/misc:src/sparse:src/spherepack
# Defaults
compiler  = gnu#		intel or gnu
debug     = optim#		work or optim
interface = lp64#		lp64 or ilp64 (long integers)
threading = parallel# 	parallel or sequential
sd        = static#		static or dynamic
_ia       = intel64#	intel64 or ia32

# -----------------------------------------------------------------------------
# Significant suffixes [assuming Fortran 90 (.f90) and possibly Fortran 77
# (.f) source code]:

.SUFFIXES : .o .mod .f90 .f

# -----------------------------------------------------------------------------
# (a) Set Fortran version and compiler options:               (COMPILER MACROS)
ifeq ($(compiler),gnu)
  FC = gfortran
#Include directory with mod files
  MOD_INC = -Jmod/
  
  OPTS = -w -ffixed-line-length -fcray-pointer  #-fno-second-underscore #-x f77-cpp-input
  #FPPSTOP=-x none
  OPTS +=  -fimplicit-none -ffree-form $(MOD_INC)
  
ifeq ($(debug),work)
  OPTS += -g -fbounds-check -Wall -Wextra -fbacktrace -finit-real=nan #-fconvert=big-endian
else
  OPTS += -DNO_DEBUG -O3 -malign-double -funroll-all-loops
endif 
  
  IFACE_COMP_PART = gf
  IFACE_THREADING_PART = gnu
else
  FC = ifort
#Include directory with mod files
  MOD_INC = -module mod/
  
  OPTS = -w -132 -fpp
  OPTS += -implicitnone -free $(MOD_INC) -sox

ifeq ($(debug),work)
  OPTS += -g -check all -fpe0 -warn -mp -traceback -debug extended
else
  OPTS += -O3 -fast -ipo  -IPF-fp-relaxed
endif
  
  IFACE_COMP_PART = intel
  IFACE_THREADING_PART = intel
endif


ifeq ($(sd),static)
  EXT=a
  RES_EXT=lib
  S_GRP=-Wl,--start-group
  E_GRP=-Wl,--end-group
else
  EXT=so
  RES_EXT=so
  S_GRP=
  E_GRP=
endif

ifeq ($(_ia),ia32)
  ifeq ($(interface),ilp64)
    $(warning  *** ILP64 interface is not available for MKL-IA32)
    $(error Try >make help)
  endif
  ifeq ($(compiler),intel)
      # This option tells the compiler to generate optimized code
      # for Pentium or later processor.
      # If you don't need it, you can remove this option.
    OPTS += -mia32
  endif
  IFACE_SUFF=
  M32_64 = -m32 # This option tells compiler to generate code for IA-32 architecture.
else
  IFACE_SUFF=_$(interface)
  M32_64 = -m64 # This option tells compiler to generate code for Intel64 architecture.
endif

ifeq ($(interface),ilp64)
  ifeq ($(compiler),gnu)
    OPTS += -fdefault-integer-8
  else
    OPTS += -i8
  endif
endif

# -----------------------------------------------------------------------------
# (b) Set library paths & names, and include file paths:  (PATH AND LIB MACROS)
MY_LIB_PATH = /home/amsta/amtvl/Desktop/scratch/lib
MY_INC_PATH = /home/amsta/amtvl/Desktop/scratch/lib

#Place of Sparse BLAS objects and modules
#SB_LIB = -L${MY_LIB_PATH}/spblas/SOFTWARE -lSparseBLAS
#SB_INCL = -I${MY_INC_PATH}/spblas/SOFTWARE

#Place of numeric libraries
MATH_LIBS = -llapack -lblas -lgfortran -lm
 
#Place of UMFPACK libraries
L_UMF = -L${MY_LIB_PATH}/SuiteSparse/UMFPACK/Lib -lumfpack
L_AMD = -L${MY_LIB_PATH}/SuiteSparse/AMD/Lib -lamd
L_CHOL = -L${MY_LIB_PATH}/SuiteSparse/CHOLMOD/Lib -lcholmod
L_COL = -L${MY_LIB_PATH}/SuiteSparse/COLAMD/Lib -lcolamd
UMFPACK_LIB = ${MY_LIB_PATH}/SuiteSparse/UMFPACK/Demo/umf4_f77zwrapper.o \
          -lblas -lgfortran -lm $(L_UMF) $(L_AMD) $(L_CHOL) $(L_COL)

I_UMF_F = -I${MY_INC_PATH}/SuiteSparse/UMFPACK/Lib -lumfpack

#Place of NetCDF libraries and modules
ifeq ($(compiler),gnu)
NETCDF_LIB = -L${MY_LIB_PATH}/netcdf/gfortran_v/lib/ -lnetcdf
NETCDF_INC = -I${MY_INC_PATH}/netcdf/gfortran_v/include/
else
NETCDF_LIB = -L${MY_LIB_PATH}/netcdf/ifort_v/lib/ -lnetcdf
NETCDF_INC = -I${MY_INC_PATH}/netcdf/ifort_v/include/
endif
#Place of MKL libraries
ifndef MKLROOT
  MKLROOT=/OPTS/intel/composerxe-2011.5.220/mkl
endif
MKL_INC = -I$(MKLROOT)/include
MKL_PATH = $(MKLROOT)/lib/$(_ia)
CMPLR_PATH = $(MKLROOT)/../compiler/lib/$(_ia)

IFACE_LIB=$(MKL_PATH)/libmkl_$(IFACE_COMP_PART)$(IFACE_SUFF).$(EXT) # IFACE_LIB=$(MKL_PATH)/libmkl_intel_lp64.a
CORE_LIB=$(MKL_PATH)/libmkl_core.$(EXT) # CORE_LIB=$(MKL_PATH)/libmkl_core.a
ifeq ($(threading),sequential)
  THREADING_LIB=$(MKL_PATH)/libmkl_sequential.$(EXT)
  OMP_LIB =
else
  THREADING_LIB=$(MKL_PATH)/libmkl_$(IFACE_THREADING_PART)_thread.$(EXT) # THREADING_LIB=$(MKL_PATH)/libmkl_intel_thread.a
  OMP_LIB = -L$(CMPLR_PATH) -liomp5
endif

#Place of SPARSKIT library
SKIT_LIB = -L${MY_LIB_PATH}/SPARSKIT2 -lskit
#L_NLC = ${MY_LIB_PATH}/NCL/lib -lncarg -lncarg_gks -lncarg_c
#L_X11 = -L/usr/lib64/ -lX11

#------------------------------------------------------------------------------
# (c) Set program (executable file) name:                      (PROGRAM TARGET)

        PROGRAM = baro_v1

# -----------------------------------------------------------------------------
# (d) Create expected object file list, with .o and .mod extension: [TARGETS OF PRE-
#     REQUISITE (.f90,.f) SOURCE FILES]

SOURCES=baro_v1.f90 
OBJECTS=$(SOURCES:%.f90=obj/%.o)

# high level modules
MODULES_H_S=projection.f90 baro_domain_integrals.f90 baro_solver.f90
MODULES_H_O=$(MODULES_H_S:%.f90=obj/%.o)
MODULES_H_M=$(MODULES_H_S:%.f90=mod/%.mod)
# medium level modules
MODULES_M_S=read_etopo.f90 generate_global_grid.f90  generate_matrices.f90 sal.f90 unsym_solvers.f90
MODULES_M_O=$(MODULES_M_S:%.f90=obj/%.o)
MODULES_M_M=$(MODULES_M_S:%.f90=mod/%.mod)
# low level modules
MODULES_L_S=my_trigs.f90 control_file.f90 err_manager.f90 my_sparse.f90 my_sparse_aggregate.f90 save_load.f90  spherepack_iface.f90
MODULES_L_O=$(MODULES_L_S:%.f90=obj/%.o)
MODULES_L_M=$(MODULES_L_S:%.f90=mod/%.mod)
# parameter level modules
MODULES_P_S=precisions.f90 
MODULES_P_O=$(MODULES_P_S:%.f90=obj/%.o)
MODULES_P_M=$(MODULES_P_S:%.f90=mod/%.mod)
# sparskit subroutines
SPARSKIT_S=blassm.f formats.f unary.f
SPARSKIT_O=$(SPARSKIT_S:%.f=obj/%.o)
# spherepack subroutines
SPHEREPACK_S=sphcom.f hrfft.f shaes.f shaec.f
SPHEREPACK_O=$(SPHEREPACK_S:%.f=obj/%.o)
# dispmodule subroutines
DISPMODULE_S=dispmodule.f90
DISPMODULE_O=$(DISPMODULE_S:%.f90=obj/%.o)

#SOURCES2=bye.f90 module1.f90
#OBJECTS2=$(SOURCES2:.f90=.o)
EXECUTABLE=global_topo

# -----------------------------------------------------------------------------
# (g) Assign dependents to target on dependency line & link options on command
#     line. Command line is initiated with a tab. ($@ is an internal macro for
#     the current target.)

#all: $(SOURCES) $(EXECUTABLE)

#${PROGRAM}: $(OBJECTS)
#
#	$(FC) -o $@ $(OBJECTS) $(MODULES_H_O) $(MODULES_M_O) $(MODULES_L_O) $(SPARSKIT_O) \
#	            ${COMPILER_OPTS} \
#	            $(NETCDF_LIB) \
#	            $(SKIT_LIB) \
#	            $(UMFPACK_LIB)

${PROGRAM}: $(OBJECTS)

	$(FC) $(M32_64) $(OPTS) -I$(MKLROOT)/include \
	$(OBJECTS) $(MODULES_H_O) $(MODULES_M_O) $(MODULES_L_O)  $(SPHEREPACK_O) $(SPARSKIT_O) $(DISPMODULE_O) \
	$(SKIT_LIB) \
	$(NETCDF_LIB) \
	$(UMFPACK_LIB) \
	$(FPPSTOP) $(S_GRP) \
	$(IFACE_LIB) \
	$(THREADING_LIB) \
	$(CORE_LIB) \
	$(E_GRP) $(OMP_LIB) -lpthread -lm -o $@

# -----------------------------------------------------------------------------
# Individual compilation using significant suffix. (`make' uses the suffix rule
# .f90.o: f90 -c ... $< to compile .f90 prerequisite files into their .o target
# files if any of the .f90 files were modified since the last make. Same for
# .f.o: f90 -c ... $<.)
#
#.f90.o :
#	f${FORTRAN_VER} -c ${OPTS} $<
#
#.f.o :
#	f${FORTRAN_VER} -c ${OPTS} ${INCLUDE_PATHS} $<

	
obj/baro_v1.o: baro_v1.f90 $(MODULES_H_O) 
	$(FC) -c ${OPTS} $< -o $@
	
$(MODULES_H_O): obj/%.o: %.f90 $(MODULES_M_O) $(SPARSKIT_O)
	$(FC) -c ${OPTS} $(MKL_LIB) $< -o $@
	
$(MODULES_M_O): obj/%.o: %.f90 $(MODULES_L_O)
	$(FC) -c ${OPTS} $< -o $@

$(MODULES_L_O): obj/%.o: %.f90 $(MODULES_P_O) $(SPHEREPACK_O) $(DISPMODULE_O)
	$(FC) -c ${OPTS} $< -o $@

$(SPARSKIT_O): obj/%.o: %.f $(MODULES_P_O)
	$(FC) -c -O3 $(MOD_INC) $< -o $@

$(SPHEREPACK_O): obj/%.o: %.f $(MODULES_P_O)
	$(FC) -c ${OPTS} $< -o $@

$(DISPMODULE_O): obj/%.o: %.f90
	$(FC) -c ${OPTS} $< -o $@
	
$(MODULES_P_O): obj/%.o: %.f90
	$(FC) -c ${OPTS} $< -o $@

obj/read_etopo.o: read_etopo.f90 $(MODULES_L_O)
	$(FC) -c ${OPTS} $(NETCDF_INC) $< -o $@

obj/unsym_solvers.o: unsym_solvers.f90 $(MODULES_P_O) $(MODULES_L_O)
	$(FC) -c ${OPTS} $(MKL_INC) $< -o $@
	

#umf_test: /home/amsta/amtvl/Desktop/scratch/lib/SuiteSparse/UMFPACK/Demo/umf4zhb.f
#	$(FC) -O -o umf $< $(UMFPACK_LIB)

# -----------------------------------------------------------------------------
# (e, f) SPECIAL TARGET for compiling files containing modules so that
#        module_name.kmo files and associated object files are created or
#        updated before all other source code object files. Also, a target
#        is provided for removing object files and the executable. Invoke
#        this target as make CLEAN. (A tab must proceed the /bin/rm.)
 
#modules:
#	$(FC) -c ${OPTS} MOD_*.f90

test: test.f90
	$(FC) $(M32_64) $(OPTS) -I$(MKLROOT)/include \
	$< $(FPPSTOP) $(S_GRP) \
	$(IFACE_LIB) \
	$(THREADING_LIB) \
	$(CORE_LIB) \
	$(E_GRP) $(OMP_LIB) -lpthread -lm -o test

clean:
#	rm -f *.o *~ *.mod ${PROGRAM}
	rm -f obj/*.o
	rm -f mod/*.mod		

show:
	echo $(MODULES_L_S) $(MODULES_M_S) $(MODULES_H_S)
	
	
